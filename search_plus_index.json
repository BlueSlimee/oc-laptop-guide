{"./":{"url":"./","title":"Getting Started","keywords":"","body":"Getting Started Why OpenCore? Many guides out there use Clover - and for good reason. It's been around for many years and there is a large knowledge base around it. Recently though, Clover has been showing glaring pitfalls - many of which OpenCore solves. Starting with release 5092, Clover does not inject ethernet/wifi kexts when going into the installer, making the internet installation method impossible. Additionally, laptops sometimes will refuse to boot with Clover. OpenCore has a cleaner codebase and clear debug logging OpenCore has a large amount of documentation On average, will start up faster Supports Bless and Bootcamp switching Has further developments to AptioMemoryFix directly within OpenCore and FwRuntimeServices Uses a kext injection method which is more future proof, which does not break System Integrity Protection (SIP) That said, Hackintosh on a laptop is still hard. You'll likely still spend tens of hours reading documentation and troubleshooting. If you are here to just make things work and not spend the time learning, then you are better off buying a macbook instead. This guide is forked from Fewtarius' laptop-guide, and a lot of the content from this guide not only comes him, but many other people. Here is a section from his guide: `On that note, while it's impossible to personally thank everyone in the community; I do want to specifically thank the following people for their help and their contributions to myself, to this guide, and to the community. This guide would not have been possible without their guidance, and their knowledge. CorpNewt Midi Dids Dhinak G Alexandred Hackintosh Slav osy Goldfish64 Also a special thanks to all of the helpers on /r/Hackintosh and HackintoshParadise.` This guide is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License, like the guide that this is forked from. That means you're welcome to share and adapt the work, but this guide is not for commercial use. If you do reuse it in whole or in part, any bits that you do use must use the same license and you'll need to provide proper attribution. Alright, what are you waiting for? Click the box at the bottom of the page to continue and let's get started "},"a-guide-to-build-guides.html":{"url":"a-guide-to-build-guides.html","title":"A Guide to Build Guides","keywords":"","body":"A Guide to Build Guides Welcome to the Internet! Here we have guides of all shapes and sizes, simple guides, complex guides, and even word salads tagged \"guide\" such as the one you're reading right now! Using guides to configure your system after installing can be OK but here is some general guidance to follow before tripping and falling down that rabbit hole. Is the Guide Complete? In my opinion a complete guide contains the following information: Is the Guide up to date? At the time of writing (Jan 2020), Opencore is under heavy development and many of the quirks and behaviors change between releases. Guides tend to go out of date quickly, meaning that the supplied Config.plist may not even boot. Hardware details The more information the better, there are so many variations of laptops out there that there are sub model identifiers within models. A good guide will identify things like: Model - The full model of the device including the variation designator. CPU - The precise model. RAM - Better if it includes the slot configuration! GPU - Is that guide for the 7th gen HP Omen laptop with the RX 580 or the GTX 1060? DISKS - Size, and configuration (m.2 or SATA, NVMe or no?) AUDIO CODEC - ALC/Conexant? Best if it includes the layout ID. WIFI/BLUETOOTH - What did it have, and what was it replaced with? NETWORK - Does it have a built in ethernet device, does it match yours? INPUT DEVICES - Is the keyboard PS/2, is it backlit? Is the touchpad I2C? Is there a touch display? Other helpful information to note are ancillary devices like the webcam, and devices that don't work. Does it Include Firmware Configuration? We covered the basic BIOS configuration changes, but many devices have additional changes to be made. A good guide will document these settings. Are there Installation Steps? This is only really important if there is some deviation from the norm. It's a nice to have though. Does the guide require you to disable SIP and/or Gatekeeper?! A lot of guides out there sacrifice security for convenience, and they often neglect to inform the users of these guides why they're doing it. Whether it's intentional or not is unimportant, but you need to look for a few red flags, and if you find them you should stop using that guide. The table below describes what to look for, and why it's important to leave enabled. Property / Command Parameter Function CsrActiveConfig (config.plist) Any value other than 0x0 This parameter enables System Integrity Protection. If it's set to any other value SIP is partially or fully disabled. SIP prevents unsigned packages from being injected into the kernel, and prevents applications from overwriting nvram values among other things. When injecting hack kexts via C/k/O it is not necessary to disable. spctl (Terminal) --master-disable This command disables Gatekeeper and allows any binary downloaded from the internet to be executed without being audited. Instead simply control-click or right-click and open your binary package leaving Gatekeeper enabled. * Does the configuration include the user's DSDT and serial numbers? This is an indicator that the writer either didn't take the time to clean up before publishing, or they didn't know enough about their Hackintosh to know they should. Abort. Does the configuration include everything you need for a working hackintosh? If it does, ask yourself when was the last time it was updated? If there's a large gap between the publish date and the current date, abort. If it's maintained, it might be OK. Check the sources before continuing. Does the configuration include only the deviations from standard? Maybe it has a clean config.plist, a usb map, and a few SSDTs or even a kext for something that's hard to find. In this case, it's probably OK. Still want to check that source though! Does the guide link to sources? If not, does it at least provide enough information to help you find them yourself? If not, it's probably best to avoid unless you're up for more work which you may be since you're still here! "},"before-you-start/know-your-hardware.html":{"url":"before-you-start/know-your-hardware.html","title":"Know Your Hardware","keywords":"","body":"Know Your Hardware Know your Hardware! Knowing your hardware is the single most imporant component of your Hackintosh journey. Your laptop has a lot of components ranging from the CPU and memory to WIFI and USB ports. Learning everything you can down to the physical IDs and locations of components on the bus can make the difference between a successful and relatively painless Hackintosh experience, and failure. Remember, the only person responsible for the success or failure of your build is you! With that in mind, it's important to note that you are also responsible should anything go wrong or if your computer breaks by following any of the advice or guidance provided by this guide. Vendor Manuals Your laptop vendor publishes information that documents the general makeup of your system. You want to start here. Download the users manual, and read it from cover to cover. If your vendor also publishes a service manual, that will be very helpful to read in advance. Examples of where this documentation will come in handy would be locating BIOS settings, or identifying part numbers of hardware for deeper inspection. Native OS Tools Your system probably ships with Windows, use the built-in tools such as System Information and Device Manager to collect general information about your hardware. Linux Tools Keep a bootable live USB of your favorite Linux distribution close by as it will include a variety of tools for deep inspection of devices. Tools such as: lspci (Display detailed information about your PCI/PCIe devices) lsusb (Same for USB devices) dmidecode (Detailed dump of DMI configuration data including memory slots, firmware, and more) A Linux USB will also be helpful in the event you need to collect information about your devices, for example it would be used to collect detailed information about your audio codec for troubleshooting purposes. Incompatible Hardware There are a lot of devices that are difficult or impossible to make work with macOS. These devices simply aren't supported, or may be partially supported but you could have serious issues. AMD CPUs AMD CPUs and their associated iGPUs are unsupported in macOS. While it's possible to work around these issues with CPU patches and adding a dGPU on a desktop, you cannot add a dGPU to a laptop. AMD systems with dGPUs often use software mux switches which are also incompatible with macOS. Intel CPUs macOS Mojave doesn't support any Intel processors earlier than generation 3 core CPUs due to a lack of Metal support in the integrated GPU. It is possible to get these processors working with various patches and hacks but you are better off staying with earlier versions of macOS instead. You can also add to this list: Pentiums Celerons Atoms WIFI cards Do you have an Intel, Atheros, Realtek, or Broadcom device that isn't a BCM94352Z, BCM943602BAED, or BCM94352HMB? Replace it with an m.2 or Mini PCIe device based one of those three cards. The Dell DW1560, DW1830, Lenovo 04X6020, and Azurewave BCM94352HMB are good choices. The DW1820A _**_works on some desktop Hackintoshes but it is incompatible with laptop Hacks. If you are installing an earlier version of macOS than Mojave, Atheros 94XX and 95XX Mini PCIe cards are supported. These cards can be used on Mojave by adding support back to macOS, but this configuration is not supported by this guide as this method could stop working at any time or could cause stability issues. Before purchasing make sure your Laptop doesn't have a whitelist that prevents the card from working. Yes, that's actually a thing. You will also need to make sure that the WIFI device is socketed and not soldered to the motherboard which has become a common theme among laptops over the last few years. GPUs Does your laptop have an AMD or Nvidia GPU? You'll need to disable it and use the onboard Intel iGPU instead. 99% of laptop dGPUs use software mux switches which are not supported in macOS due to Apple's use of a hardware mux switch. Only on some RARE configurations, especially Workstation-grade laptops. But that is still experimental and very unstable for some devices. Built in SDCard Readers If you have an SDCard reader that's connected through an internal USB hub, it's probably not going to work. Do yourself a favor if you need SDCard support and buy an inexpensive reader. If your SDCard reader is PCI based there is a small chance that it will work in macOS, but you're probably going to want to fake the ID so it appears as a native reader to the operating system. Fingerprint Readers Apple only supports their implementation of fingerprint readers through Touch ID. You may as well turn it off in your BIOS and save a little bit of power. While you're in there, turn off that USB SDCard reader as well! SmartCard Readers While some can be supported somehow, they're mostly not, and thankfully they're USB connected and can be disabled by either the BIOS/UEFI firmware Setup screen (if possible) or by remapping your USB ports and disabling it. It can potentially save some juice. "},"before-you-start/bios-configuration.html":{"url":"before-you-start/bios-configuration.html","title":"BIOS Configuration","keywords":"","body":"BIOS Configuration In order to boot macOS you have to make a few adjustments to your laptop's BIOS configuration for compatibility. Some of these settings may not appear in your BIOS, that's OK as many of them can also be corrected in OpenCore. If the parameter isn't found in your laptop's BIOS, just ignore it. For information on how to access your BIOS configuration, refer to your laptop's users manual. Turn off Secure Boot Disable it, or you won't be able to access OpenCore to boot macOS or the macOS installation media. Turn the TPM off If your computer has a TPM chip, you'll want to turn it off. macOS can't use it anyway. Disable VT-D VT-D is Intel's hardware based IO and device offload technology. It's incompatible with macOS and can cause boot issues, and kernel panics. If you have the option, you should turn it off. Graphics DVMT-Prealloc This is the initial memory used for your Intel GPU. By default it's usually 32MB, but for macOS it should be set to 64MB. If you don't have this option in your BIOS it can be patched later. SATA/AHCI/RAID You always want your Hard Disks and SSDs to operate in AHCI mode. In any of the other modes, macOS won't see them for installation. Disable that dGPU! If you can, if not you can disable it with a patch later. You may need to boot the installation media with an extra argument (-x) to use safe mode though. This setting can also be left on if you want to use the dGPU within Windows or other operating systems. Enable Legacy USB support This is sometimes needed for your keyboard to work in OpenCore. It's always safe to set if it's available. Enable XHCI Handoff This parameter tells the computer to hand control of the XHCI (USB 3) bus to macOS, if you have it make sure it's enabled. Disable Fast Boot Fast Boot establishes a cache to boot into Windows more quickly, but that can be problematic when booting into macOS. If you have the parameter, you'll want to turn it off. Disable Wake on Lan Wake on Lan is one of the leading causes of sleep wakeups, if you have the option in your BIOS to disable it, it's recommended that you do. Disable Unsupported Devices That fingerprint and some SDCard reader won't work anyway, so turn off the ports if you can and save power! (if possible) "},"useful-skills-terminology/a-little-unix-never-hurt-anyone.html":{"url":"useful-skills-terminology/a-little-unix-never-hurt-anyone.html","title":"A Little UNIX Never Hurt Anyone!","keywords":"","body":"A Little UNIX Never Hurt Anyone! If you don't know the basic UNIX commands, now is the time to read up as they will be important tools to have in your back pocket, and you'll need to know them to succeed. Here's a primer that should help get you started. How to Use Basic UNIX Commands to Work in Terminal on Your Mac All of the UNIX commands used in this guide are to be executed in a shell, and assume you are running them on macOS. For access to an OS shell in macOS, launch the Terminal app. The following table will help you know when to run a command with your user or with root. Command Prompt Run as $ Your normal user account # Run as root. Become root with command: sudo -s "},"useful-skills-terminology/just-enough-git.html":{"url":"useful-skills-terminology/just-enough-git.html","title":"Just Enough GIT","keywords":"","body":"Just Enough GIT Many of the instructions in the guide point you to Github and possibly other sites to download software or scripts from a repository. If the site offers a release package, that's what you want to download. If it doesn't however you will need to know enough about git to clone the contents of the repository to your computer. In order to install git, you will need to add some command line tools to your Hack. Here's how you install those. xcode-select --install Once the installation completes you will have the ability to run the 'git' command. This command allows you to interact with software repositories. To clone a repository to your computer, go to the site with the repository you want to clone and click the green clone or download button, then select https. Copy the URI path in the box and add it to the end of a git clone command like this. git clone https://github.com/corpnewt/USBMap.git Once it's cloned, you will be able to enter the directory and make use of the projects resources. If you'd like a little more advanced git knowledge, here are some resources to get you started! Resources to learn Git @ Github "},"useful-skills-terminology/whats-an-efi.html":{"url":"useful-skills-terminology/whats-an-efi.html","title":"What's an EFI?","keywords":"","body":"What's an EFI? An EFI partition is where a computer stores the bits needed for the system to boot. In the case of a Hackintosh, it's where OpenCore and all of the drivers and configurations that OpenCore needs to start your system are stored. As you are building your Hackintosh, you are going to become intimately familiar with this partition and its content. Older computers that don't support EFI boot OpenCore using a legacy stub. Here's how you mount it. First, inspect your partitions and find your EFI. If you have two hard disks installed, be careful to determine which one contains the correct EFI as the IDs themselves can change on every startup. diskutil list /dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *500.1 GB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_APFS Container disk1 499.9 GB disk0s2 /dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +499.9 GB disk1 Physical Store disk0s2 1: APFS Volume macOS 199.9 GB disk1s1 2: APFS Volume Preboot 46.5 MB disk1s2 3: APFS Volume Recovery 510.3 MB disk1s3 4: APFS Volume VM 20.5 KB disk1s4 In the example above, you'll note that you have one internal disk and one synthesized disk. The synthesized disk is a container that holds all of your operating system bits. The source for this container can be found at /dev/disk0s2. You should also note that the EFI partition is located on the internal physical disk at /dev/disk0s1. This is the partition that you should mount for OpenCore. Here's how you would do it. sudo mkdir /Volumes/EFI sudo diskutil mount -mountPoint /Volumes/EFI /dev/disk0s1 That's it, you're ready to work on your OpenCore installation! Simple! When you've finished editing your OpenCore folder, you can eject it in Finder or from Terminal like this. diskutil unmount /Volumes/EFI What are EFI drivers? EFI drivers are used by OpenCore to bootstrap macOS and start the process of loading the kernel and services that get you to your desktop. These are found under OC/Drivers. So what's LEGACY? Another great question! For many years computers used a basic data structure to identify where your data was stored, and how to boot your operating system. This method added a small amount of data to the very start of your hard drive. Beginning in 2004 and adopted later by vendors, Intel established a new method of booting a computer called UEFI that was 32bit and provided significantly greater flexibility. If you have support for UEFI, you should use it. If you don't however, OpenCore will still accomodate you. You will also access your OpenCore directory the same way, the major difference is how the system recognizes and bootstraps the OpenCore bootloader. As Legacy is well..Legacy..these types of installations usually require a lot of additional work which is not covered by this guide. "},"useful-skills-terminology/what-about-kexts.html":{"url":"useful-skills-terminology/what-about-kexts.html","title":"What about KEXTs?","keywords":"","body":"What about KEXTs? Glad you asked! A kext is a kernel extension that adds functionality and hardware support to macOS. There are some rules around kexts that you need to know, and here they are. KEXT Paths /System/Library/Extensions (/S/L/E) - This is where Apple stores the kexts that macOS uses to boot and operate. If something is telling you to put a kext here, hard stop because it's probably wrong. /Library/Extensions (/L/E) - This is a place for 3rd party developers to place signed kexts for hardware that you buy and connect to your computer. These developers have been granted a kernel signing certificate that is used to sign the kexts which tells macOS they're safe to use. Many (if not all) kexts that we are using are neither signed or endorsed by Apple. If something tells you to put a kext here, hard stop as the same rule applies. EFI/OC/Kexts (OC/K) - This is the location that OpenCore uses to inject functionality into the operating system for your Hackintosh to boot and operate. This is where all of your Hackintosh kexts go. Did you notice the lack of a slash before OpenCore? That's because you need to reference where you've mounted your EFI partition before adding OC/K. Remember that, you'll need to add the mount path anywhere in the guide that it's mentioned. Do NOT use S/L/E (or SLE for short) to install kexts to on 10.11 and later, it's usually secured by SIP for a reason. Learn more about System Integration Protection here. Following this policy keeps your system clean and allows you to fully enable System Integrity Protection increasing the security of your laptop. "},"prepare-install-macos/preparing-the-usb-media.html":{"url":"prepare-install-macos/preparing-the-usb-media.html","title":"Preparing the USB Media","keywords":"","body":"Preparing the USB Media Prepare macOS for Installation For this step, you'll need a USB thumb drive that's 16GB or larger, and if possible it should be USB 2.0. Plug the stick into another Computer before continuing. This procedure will erase the USB drive, so save any files to another location before proceeding. For this section, I'm going to hand you off to Hackintosh Slav's OpenCore guide to set up the USB initially. You will want to follow both the \"Creating the USB\" page AND the \"Gathering Files\" page within the guide linked above. "},"prepare-install-macos/clover-template.html":{"url":"prepare-install-macos/clover-template.html","title":"OpenCore Template","keywords":"","body":"OpenCore Template The Config.plist in a Nutshell Before continuing, you need a bit of knowledge about the config.plist which is a structured text document (XML) that provides OpenCore with the instructions that it needs to customize your laptop to boot and use macOS. It is a complex, and sometimes daunting dictionary of key value pairs. There are a variety of tools available to help configure it, here are a few to help get you started. ProperTree - This is a cross platform plist editor written by CorpNewt that works on Windows, Linux, and macOS. It's a very simple, but very powerful tool that simplifies changing parameters while also helping ensure you don't break formatting rules. Download ProperTree from Github. XCode - You probably don't want (Or need) to install an entire development suite for editing your plist, but it is an option so it's worth mentioning. If you're looking to take a tank to a knife fight, XCode can be installed through the App Store. It is also woth noting that Xcode has issues editing plists starting with Xcode 11. PlistBuddy - This is a command line utility that's built into macOS. It's a great utility for making changes to plist files from scripts or the command line. $ /usr/libexec/PlistBuddy --help Making your own Config.plist OpenCore config files (and EFIs in general) tend to be very similar to Desktop ones. Because of this, I will link you to Hackintosh Slav's guide again to set up the Config.plist. When following the guides below: DO NOT insert SSDT-EC. On the next page, we'll go over how to rename the EC already existing within your ACPI tables. Instead of using the imac models provided in the guide, use one of the models provided by the table below each link (Generally choose the one that matches your laptop closest) Remember that anytime you add a Kext, Driver, Tool, or SSDT, you need to add it to your Config.plist. The OC Snapshot tool from ProperTree can automatically add these for you. Ivy Bridge Model Graphics Size Year MacBookPro9,1 HD 4000/GeForce GT 650M 15\" 2012 MacBookPro9,2 HD 4000 13\" 2012 MacBookPro10,1 HD 4000/GeForce T 650M 15\" 2012/13 MacBookPro10,2 HD 4000 13\" 2012/13 Haswell Model Graphics Size Year MacBookPro11,1 Irs 5100 13\" 2013/14 MacBookPro11,2 Irs Pro 5200 15\" 2013/14 MacBookPro11,3 Irs Pro 5200/GeForce GT 750M 15\" 2013/14 MacBookPro11,4 Irs Pro M5200 15\" 2015 MacBookPro11,5 Irs Pro 5200/Radeon R9 M370x 15\" 2015 Broadwell (Uses Haswell config) Model Graphics Size Year MacBookPro12,1 Iris 6100 13\" 2015 Skylake Model Graphics Size Year MacBookPro13,1 Iris 540 13\" 2016 MacBookPro13,2 Iris 550 13\" 2016 MacBookPro13,3 HD 530/Radeon Pro 450 15\" 2016 Kaby Lake Model Graphics Size Year MacBookPro14,1 Iris Plus 640 13\" 2017 MacBookPro14,2 Iris Plus 650 13\" 2017 MacBookPro14,3 HD 630/Radeon Pro 555 15\" 2017 Coffee Lake Model Graphics Size Year MacBookPro15,1 UHD 630/Radeon Pro 555X 15\" 2018 MacBookPro15,2 Iris Plus 655 13\" 2018 MacBookPro15,3 UHD 630/Vega 16/20 15\" 2018 MacBookPro15,4 Iris Plus 645 13\" 2019 Coffee Lake Refresh (14nm +++++++++++++++++++) Model Graphics Size Year MacBookPro16,1 UHD 630/Radeon Pro 5300M 16\" 2019 "},"prepare-install-macos/setting-up-input-devices.html":{"url":"prepare-install-macos/setting-up-input-devices.html","title":"Setting up Input Devices","keywords":"","body":"Setting up Input Devices Input devices on laptops come in a few variants, each with its own set of quirks. Most laptops will want VoodooPS2 for the keyboard. For your trackpad, it's a good idea to check device manager in windows if possible to see what trackpad you have. VoodooPS2 (Keyboard and Trackpad) Most laptop keyboard and trackpads are PS/2 devices. You should only need the two listed below. These should cover most Synaptics touchpads used in recent laptops. VoodooInput Project Page Used by VoodooPS2 to emulate a Magic Trackpad Should be listed first in your Config.plist as it is required for VoodooPS2Trackpad to load VoodooPS2Controller Project Page Actually is 4 kexts bundled into one kext package. VoodooPS2Controller VoodooPS2Keyboard VoodooPS2Trackpad VoodooPS2Mouse Make sure when adding this to your config.plist that all 4 of these appear Download the two kexts and place them in your EFI as shown below. EFI └── OpenCore └── Kexts ├── VoodooInput.kext └── VoodooPS2Controller.kext The Kexts below do not need VoodooInput If you have issues running the above version of VoodooPS2 (the case of a hard surface trackpad), you may want to try Rehabman's version of VoodooPS2Controller: VoodooPS2Controller Project - Rehabman @ BitBucket If you have an Alps trackpad, you will want this version here: VoodooPS2-Alps - 1Revenger1 VoodooI2C (Touchscreens and I2C Trackpads) I2C touchpads are interesting in that they fully integrate into macOS and support gestures and everything that a real Apple Trackpad supports, except force touch (obviously). Not all I2C touchpads are supported by I2C or without extra hotpatches to configure pinning. An unusual requirement for the trackpad to work is functional battery status reporting, so if you don't have that working yet skip to that section and then come back. Most though work fine with just two hotpatches that are pretty simple to install. Let's add them now. First, download SSDT-XOSI.dsl. Rehabman's SSDT-XOSI.dsl @ Github Now that you've saved the file, you'll need to compile it. For that, we need to download maciASL. maciASL Project @ Github Run maciASL, and open the SSDT-XOSI.dsl that you created previously. Save the file as a binary to OC/ACPI/SSDT-XOSI.aml. Note: When saving as a binary, maciASL will automatically compile the SSDT. _OSI to XOSI Rename Now that you've added the XOSI SSDT patch, you need to add a patch to OpenCore. Open your config.plist with your plist editor of choice and add the following patch under ACPI/Patch. If you're using the guide template this rename already exists so just make sure it's enabled. Key Type Value Comment String _OSI to XOSI Enabled Bool True Find Data 5f4f5349 Replace Data 584f5349 Save config.plist and close the editor. You should have this already if you're using the config template from before. Make sure it's enabled. SSDT-GPI0 Next we'll create a stub function for GPI0 using another SSDT patch. Paste the following data into maciASL. DefinitionBlock (\"\", \"SSDT\", 2, \"hack\", \"I2C\", 0) { External (_SB.PCI0.GPI0, DeviceObj) Scope (_SB.PCI0.GPI0) { Method (_STA, 0) { Return (0x0F) } } } Using MaciASL, save this SSDT patch as a binary to OC/ACPI/SSDT-GPI0.aml Installing VoodooI2C With the hotpatching out of the way, now it's time to install VoodooI2C. Generally you only want to install VoodooI2C.kext and VoodooI2CHID.kext to C/k/O as this is the proper configuration for most devices regardless of manufacturer. Start there, and then come back after rebooting for a description of the kexts and what their functions are. Download VoodooI2C @ Github Kexts and Satellites When configuring VoodooI2C, it is important to only apply the kexts that you need. Generally, most users will need VoodooI2C.kext and VoodooI2CHID.kext. The remaining satellites are for a small number of specific devices. Even if you have an Elan or Synaptics touchpad, you should try the HID kext first. If you do learn that you need a different satallite kext, remove the HID kext before applying it. VoodooI2C - This is the primary device driver that implements Apple's Trackpad protocols. VoodooI2CHID - Implements the Microsoft HID device specification. VoodooI2CElan - Implements support for Elan proprietary devices. (does not work on ELAN1200+, use the HID instead) VoodooI2CSynaptics - Implements support for Synaptics proprietary devices. VoodooI2CFTE - Implements support for the FTE1001 touchpad. VoodooI2CUPDDEngine - Implements Touchbase driver support. The VoodooI2C configuration should match the tree view below. EFI └── OpenCore └── Kexts ├── VoodooI2C.kext └── VoodooI2CHID.kext └── Contents (already inside, you do not need to add them) └── Plugins ├── VoodooGPIO.kext └── VoodooI2CServices.kext I know that you've kind of breezed through this one, but we don't want to make it too easy, so here's some required reading. VoodooI2C Documentation The documentation covers troubleshooting, GPIO pinning, and other topics that may be important tools in troubleshooting any problems you may face while setting up your touchpad device. For this kext to properly load on your OpenCore setup, you must make sure that the loading order is as follows: VoodooI2CServices VoodooGPIO VoodooI2C Example: Using VoodooI2C + VoodooI2CHID BundlePath VoodooI2C.kext/Contents/PlugIns/VoodooI2CServices.kext Comment Enabled ExecutablePath Contents/MacOS/VoodooI2CServices MaxKernel MinKernel PlistPath Contents/Info.plist BundlePath VoodooI2C.kext/Contents/PlugIns/VoodooGPIO.kext Comment Enabled ExecutablePath Contents/MacOS/VoodooGPIO MaxKernel MinKernel PlistPath Contents/Info.plist BundlePath VoodooI2C.kext Comment Enabled ExecutablePath Contents/MacOS/VoodooI2C MaxKernel MinKernel PlistPath Contents/Info.plist BundlePath VoodooI2CHID.kext Comment Enabled ExecutablePath Contents/MacOS/VoodooI2CHID MaxKernel MinKernel PlistPath Contents/Info.plist A note on Touchscreens: If you have one of those fancy 2-in-1 laptops with a touch screen, it may be supported by VoodooI2C as well! Touchscreens are either I2C or USB devices, so configuring your touchpad should also enable your touch display when supported. Some things to keep in mind: You'll want to use VoodooI2C with VoodooI2CHID. If it's I2C, it should work as long as your GPI0 and XOSI are properly fixed, and it's USB, there is a chance that it may attach. The VoodooI2C documentation doesn't guarantee that all USB touchscreens will work. USB Touchscreens may work as a single pointer device while in the installer phase, I2C touchscreens may not work until the full macOS installation boots up. Bluetooth Keyboard and Mice One of the common questions asked is if users can use their bluetooth keyboard and mouse in the BIOS and OpenCore, and the answer to that is yes... but! In order for these devices to work in pre-boot environments like the BIOS, in OpenCore, or even in the FileVault Prebooter; the bluetooth adapter needs to support a profile called HID Proxy. This profile allows your devices to connect to the adapter before booting the OS and it passes them to the system as a USB keyboard and mouse. Without this profile, it is not possible to use these devices until you're in the operating system. "},"prepare-install-macos/disabling-touchid.html":{"url":"prepare-install-macos/disabling-touchid.html","title":"Disabling TouchID lookup","keywords":"","body":"Disabling TouchID lookup When using the SMBIOS of a MacBook Pro with TouchID, you may notice quite a lot of lag getting to the login screen, or whenever you need to enter your password. The cause of this is macOS trying to communicate with the TouchID sensor. Additionally, there can be issues with the device hanging at the Welcome screen after installing macOS. Even though you don't have one, the OS thinks that you do so it will continue to try to authenticate with it until you turn it off. The good news here is that turning it off is incredibly simple, you just need the NoTouchID kext from al3xtjames's Github. Download it using the link below, and install it to OC/K. If you're using an SMBIOS that doesn't have TouchID, you can skip this one. Download NoTouchID @ Github The location of the kext should match the tree view below. EFI └── OpenCore └── Kexts └── NoTouchID.kext "},"prepare-install-macos/embedded-controller-ec.html":{"url":"prepare-install-macos/embedded-controller-ec.html","title":"Embedded Controller (EC)","keywords":"","body":"Embedded Controller (EC) Embedded Controller (EC) Starting in macOS 10.15 (Catalina), macOS now stalls when booting and attaching to an EC with the device id of \"PNP0C09\" and is not named EC within the ACPI tables. This normally manifests itself as messages similar to apfs_module_start... or waiting for root device when attempting to boot. With a desktop, we would normally just put in a fake embedded controller with the correct properties and call it a day - but for laptops we rename the existing embedded controller in order to get battery status working. The general gist is that: You need to dump your DSDT Decompile said DSDT Figure out which EC is the main one in your DSDT Put in the right rename into the patches section of your Config.plist For more info, you can read this guide, also by Hackintosh Slav. This page is more or less a copy and paste from the laptop page specifically. Dumping the DSDT MaciASL When you open MaciASL, it should open directly to your system's DSDT. If it does not, you can go into the top left corner and hit \"File\" -> \"New from ACPI\" -> \"DSDT\". What you are seeing is the decompiled form of your DSDT, so you can skip ahead to figuring out which EC you need. This needs to be done on the target computer, and if you have any ACPI fixes or patches applied from Clover or OpenCore, those will be applied to the DSDT you see in MaciASL. SSDTTime Can be ran on either Windows or Linux If you don't have an internet connection on that device, or are using Python 2 (or iasl otherwise fails to download) you may need to download iASL.exe and acpidump.exe and put it in the scripts folder`. macOS Windows Linooox acpidump.exe In command prompt run path/to/acpidump.exe -b -n DSDT -z, this will dump your DSDT as a .dat file. Rename this to DSDT.aml Pressing F4 in Clover This dumps your DSDT in EFI/CLOVER/ACPI/origin. This folder must exist bfeore you dump though. acpidump.efi Add this to EFI/OC/Tools and in your config under Misc -> Tools with the argument: -b -n DSDT -z. Select this option in OpenCore's picker, then rename DSDT.dat to DSDT.aml. If OpenCore is having issues running acpidump, you can call it from the shell with OpenCoreShell(reminder to add to both EFI/OC/Tools and in your config under Misc -> Tools ): shell> fs0: // replace with proper drive fs0:\\> dir // to verify this is the right directory Directory of fs0:\\ 01/01/01 3:30p EFI fs0:\\> cd EFI\\OC\\Tools // note that it's with forward slashes fs0:\\EFI\\OC\\Tools> acpidump.efi -b -n DSDT Decompiling the DSDT So once we have our DSDT we still got a bit of work left, we'll first want to decompile it so we can view it easier. Couple options: macOS So decompiling DSDTs is quite easy with macOS, all you need is MaciASL. To decompile, just open the file! Windows Decompiling on windows is fairly simple as well, you will need iasl.exe and Command Prompt: path/to/iasl.exe path/to/DSDT.aml Linux Compiling and decompiling with Linux is just as simple, you will need a special copy of iasl and terminal: path/to/iasl path/to/DSDT.aml Finding the right EC patch Now that our DSDT is readable, next search for PNP0C09. Should give you something similar to this: As you can see our PNP0C09 is found within the Device (EC0) meaning this is the device we want to rename. What happens if multiple PNP0C09 show up When this happens you need to figure out which is the main and which is not, it's fairly easy to figure out. Check each controller for the following properties: _HID _CRS _GPE Note that only the main EC needs renaming, if you only have one PNP0C09 then it is automatically your main regardless of properties. Applying your EC patch As you can see from the table below, we'll be renaming our EC listed in the DSDT. Do note you cannot just throw random renames without checking first, as this can cause actual damage to your laptop. Comment Find*[HEX] Replace[HEX] change EC0 to EC 4543305f 45435f5f change H_EC to EC 485f4543 45435f5f change ECDV to EC 45434456 45435f5f change PGEC to EC 50474543 45435f5f Add the rename as shown below: Comment String Change XXXX to EC Enabled String YES Count Number 0 Limit Nuber 0 Find Data xxxxxxxx Replace Data xxxxxxxx "},"prepare-install-macos/display-configuration.html":{"url":"prepare-install-macos/display-configuration.html","title":"Display Configuration","keywords":"","body":"Display Configuration Configuring a laptop's integrated GPU is a lot like configuring a desktop's integrated GPU. You usually start by disabling the dedicated GPU if you have one. This section will talk about the methods that you would use for each component of GPU configuration and how to test that it's working, but there are better guides that already exist to help with the heavy lifting. Configuring your Display Adapter (GPU) Depending on your laptop, you may have very little to do to configure your iGPU, or you could have to add an elaborate set of patches to configure stuff like DVMT. The most important thing you'll want here is the WhateverGreen kext and it's dependency, LILU. Lilu is a patching mechanism that's used by multiple kernel extensions, and WhateverGreen is responsible for patching your display adapter(s). If you haven't already added WhateverGreen to your OpenCore EFI, better do that now before continuing. You can get it here. Remember to add it to your config.plist Download WhateverGreen First things first, disable that dGPU! There are two ways to disable a dGPU in a laptop, the short way and the not so short way. We'll start with the short way because it is really simple. If you don't have a dGPU (NVidia/ATI dedicated graphics) you can skip this part and jump straight to configuring your display adapter instead. To disable your dGPU the short way, add the following to the NVRAM/Add/7C436110-AB2A-4BBB-A880-FE41995C9F82/boot-args section of your config.plist. -wegnoegpu This command instructs Whatevergreen to disable all internal and external dedicated GPUs. Mission complete? Great! If it doesn't work out the way you would expect, come back and move on the the not so short method using Hackintosh Slav's wonderful guide. How to disable your unsupported GPU for MacOS Got it all fixed up? Excellent! Now that this is behind us, it's time to configure your iGPU. iGPU Configuration Apple uses Intel graphics cards that have features other GPUs in Intel's line up don't have. For example, with a Hackintosh laptop it is generally not possible to use DRM as FairPlay 2.0 is not supported. Unfortunately it also means that macOS requires that you patch macOS to believe you have a different GPU than you really do. Since these GPUs fall within the same family, we can use the data provided within the macOS Intel driver to build a patch that enables your GPU with full acceleration. A prerequisite to configuring your iGPU is knowing which GPU you actually have. If you don't already know, look up your CPU using Intel's Ark utility. Once you find your CPU pay attention to the code name, and the graphics adapter. This information will be useful as you configure your GPU patches. iGPU Patching We can instruct Whatevergreen to patch your GPU by passing specific parameters to macOS in your config.plist. The table below describes the patches that we will be utilizing. These parameters can be found or added in your config.plist under DeviceProperties/Add/PciRoot(0x0)/Pci(0x02,0x00). Key Function AAPL,ig-platform-id This is the platform identifier of the GPU you are spoofing. (required) device-id This is the device identifier of the GPU you are spoofing. (required in cases) framebuffer-patch-enable This switch enables framebuffer patching. It is required when setting framebuffer patches such as fbmem and stolenmem. framebuffer-fbmem This patches framebuffer memory, and is used when you cannot configure DVMT to 64MB in the BIOS. Do not use if the DVMT BIOS option is available. framebuffer-stolenmem This patches framebuffer stolen memory, and is used when you cannot configure DVMT to 64MB in the BIOS. Do not use if the DVMT BIOS option is available. These parameters contain the basics to get you started. If you need more advanced patching to enable your framebuffer, review the Whatevergreen Intel GPU FAQ. The Framebuffer patches are included in the config.plist provided with this guide, however they are disabled. To enable them remove the # symbol from the beginning of the key. iGPU Patches Now you are ready to configure your patches. Use the table below to select the patch that most closely resembles the configuration from Ark. * Denotes the default configured by WhateverGreen. thicc text Denotes recommended values (taken from WhateverGreen and Rehabman laptop configs) Intel (10.x.x) Denotes the Generation of the Processor and the supported macOS versions. Intel Ivy Bridge (10.8+) iGPU device-id AAPL,ig-platform-id Port Count Stolen Memory Framebuffer Memory Video RAM Connectors Intel HD Graphics 4000 66010001 01006601 4 96MB 24MB 1536MB LVDS1 HDMI1 DP2 Intel HD Graphics 4000 66010002 02006601 1 64MB 24MB 1536MB LVDS1 Intel HD Graphics 4000 1 * 66010003 03006601 4 64MB 16MB 1536MB LVDS1 DP3 Intel HD Graphics 4000 2 66010004 04006601 1 32MB 16MB 1536MB LVDS1 Intel HD Graphics 4000 66010008 08006601 3 64MB 16MB 1536MB LVDS1 DP2 Intel HD Graphics 4000 3 66010009 09006601 3 64MB 16MB 1536MB LVDS1 DP2 Special Notes: For these cards, no device-id property is required. 1 : to be used with 1366 by 768 displays or lower (main) 2 : to be used with 1600 by 900 displays or higher (main) 3 : to be used with some devices that have eDP connected monitor (contrary to classical LVDS), must be tested with 1 and 2 first then try this. VGA is not supported (unless it's running through a DP to VGA internal adapter, which apparently only rare devices will see it as DP and not VGA, it's all about luck.) For 04006601 platform, as you can tell, it has only one output, which is not enough for external connectors (HDMI/DP), you may need to add these extra parameters (credit to Rehabman) | Key | Type | Value | Explanation | | :--- | :--- | :--- | :--- | | framebuffer-patch-enable | Number | 1 | enabling the semantic patches in principle (from WEG manual) | | framebuffer-memorycount | Number | 2 | Matching FBMemoryCount to the one on 03006601 (1 on 04 vs 2 on 03) | | framebuffer-pipecount | Number | 2 | Matching PipeCount to the one on 03006601 (3 on 04 vs 2 on 03) | | framebuffer-portcount | Number | 4 | Matching PortCount to the one on 03006601 (1 on 04 vs 4 on 03) | | framebuffer-stolenmem | Data | 00000004 | Matching STOLEN memory to 64MB (0x04000000 from hex to base 10 in Bytes) to the one on 03006601 Check here for more information. | | framebuffer-con1-enable | Number | 1 | This will enable patching on connector1 of the driver. (Which is the second connector after con0, which is the eDP/LVDS one) | | framebuffer-con1-alldata | Data | 02050000 00040000 07040000 03040000 00040000 81000000 04060000 00040000 81000000 | When using all data with a connector, either you give all information of that connector (port-bused-type-flag) or that port and the ones following it, like in this case. In this case, the ports in 04 are limited to 1: 05030000 02000000 30020000 (which corresponds to port 5, which is LVDS) However on 03 there are 3 extra ports: 05030000 02000000 30000000 (LVDS, con0, like 04) 02050000 00040000 07040000 (DP, con1) 03040000 00040000 81000000 (DP, con2) 04060000 00040000 81000000 (DP, con3) Since we changed the number of PortCount to 4 in a platform that has only 1, that means we need to define the 3 others (and we that starting with con1 to the end). | Some laptops from this era came with a mixed chipset setup, using Ivy Bridge CPUs with Sandy Bridge chipsets which creates issues with macOS since it expects a certain IMEI ID that it doesn't find and would get stuck at boot, to fix this we need to fake the IMEI's IDs in these models To know if you're affected check if your CPU is an intel Core ix-3xxx and your chipset is Hx6x (for example a laptop with HM65 or HM67 with a Core i3-3110M) In your config add a new PciRoot device named PciRoot(0x0)/Pci(0x16,0x0) Key: device-id Type: Data Value: 3A1E0000 Intel Haswell (10.9+) iGPU device-id AAPL,ig-platform-id Port Count Stolen Memory Framebuffer Memory Video RAM Connectors Intel HD Graphics 4400 160a000c 0c00160a 3 64MB 34MB 1536MB LVDS1 DP2 Intel HD Graphics 5000 1 260a0005 0500260a 3 32MB 19MB 1536MB LVDS1 DP2 Intel HD Graphics 5000 2 260a0006 0600260a 3 32MB 19MB 1536MB LVDS1 DP2 Intel Iris Graphics 5100 2e0a0008 08002e0a 3 64MB 34MB 1536MB LVDS1 DP2 Intel Iris Pro Graphics 5200 260d0007 0700260d 4 64MB 34MB 1536MB LVDS1 DP2 HDMI1 Intel Iris Pro Graphics 5200 260d0009 0900260d 1 64MB 34MB 1536MB LVDS1 Intel Iris Pro Graphics 5200 260d000e 0e00260d 4 96MB 34MB 1536MB LVDS1 DP2 HDMI1 Intel Iris Pro Graphics 5200 260d000f 0f00260d 1 96MB 34MB 1536MB LVDS1 Special Notes: 1: to be used usually with HD5000, HD5100 and HD5200 The device-id of these devices should be supported already by the native macOS drivers. 2: to be used usually with HD4200, HD4400 and HD4600. You must use device-id = 12040000 In some cases, just using these values directly would cause some glitches to show up, to mitigate them, we change the size of the cursor byte: framebuffer-patch-enable = 1 (as a Number) framebuffer-cursor = 00009000 (as Data) We change the cursor byte from 6MB (00006000) to 9MB because of some glitches. Intel Broadwell (10.10.2+) iGPU device-id AAPL,ig-platform-id Port Count Stolen Memory Framebuffer Memory Video RAM Connectors Unlisted iGPU 06160002 02000616 3 34MB 21MB 1536MB LVDS1 DP2 Unlisted iGPU 0e160001 01000e16 3 34MB 21MB 1536MB LVDS1 DP2 Intel HD Graphics 5600 12160003 03001216 4 34MB 21MB 1536MB LVDS1 DP2 HDMI1 Intel HD Graphics 5500 16160002 02001616 3 34MB 21MB 1536MB LVDS1 DP2 Intel HD Graphics 5300 1e160001 01001e16 3 38MB 21MB 1536MB LVDS1 DP2 Intel Iris Pro Graphics 6200 22160002 02002216 3 34MB 21MB 1536MB LVDS1 DP2 Intel HD Graphics 6000 26160002 02002616 3 34MB 21MB 1536MB LVDS1 DP2 Intel HD Graphics 6000 26160005 05002616 3 34MB 21MB 1536MB LVDS1 DP2 Intel HD Graphics 6000 * 26160006 06002616 3 34MB 21MB 1536MB LVDS1 DP2 Intel Iris Graphics 6100 2b160002 02002b16 3 34MB 21MB 1536MB LVDS1 DP2 Sepcial Notes: For HD5300, HD5500 and HD6000, you do not have to specify any device-id For HD5600 you need device-id faked to 26160000 In some cases where you cannot set the DVMT-prealloc of these cards to 96MB higher in your UEFI Setup, you may get a kernel panic. Usually they're configured for 32MB of DVMT-prealloc, in that case these values are added to your iGPU Properties | Key | Type | Value | | :--- | :--- | :--- | | framebuffer-patch-enable | Number | 1 | | framebuffer-stolenmem | Data | 00003001 | | framebuffer-fbmem | Data | 00009000 | Intel Skylake iGPU device-id AAPL,ig-platform-id Port Count Stolen Memory Framebuffer Memory Video RAM Connectors Intel HD Graphics 530 12190000 00001219 3 34MB 21MB 1536MB DUMMY1 DP2 Intel HD Graphics 520 16190000 00001619 3 34MB 21MB 1536MB LVDS1 DP2 Intel HD Graphics 520 16190002 02001619 3 57MB 0MB 1536MB LVDS1 DP2 Intel HD Graphics 530 * 1b190000 00001b19 3 34MB 21MB 1536MB LVDS1 DP2 Intel HD Graphics 530 1b190006 06001b19 1 38MB 0MB 1536MB LVDS1 Intel HD Graphics 515 1e190000 00001e19 3 34MB 21MB 1536MB LVDS1 DP2 Intel HD Graphics 515 1e190003 03001e19 3 40MB 0MB 1536MB LVDS1 DP2 Intel Iris Graphics 540 26190000 00002619 3 34MB 21MB 1536MB LVDS1 DP2 Intel Iris Graphics 540 26190002 02002619 3 57MB 0MB 1536MB LVDS1 DP2 Intel Iris Graphics 540 26190004 04002619 3 34MB 0MB 1536MB LVDS1 DP2 Intel Iris Graphics 540 26190007 07002619 3 34MB 0MB 1536MB LVDS1 DP2 Intel Iris Graphics 550 27190000 00002719 3 34MB 21MB 1536MB LVDS1 DP2 Intel Iris Graphics 550 27190004 04002719 3 57MB 0MB 1536MB LVDS1 DP2 Intel Iris Pro Graphics 580 3b190000 00003b19 3 34MB 21MB 1536MB LVDS1 DP2 Intel Iris Pro Graphics 580 3b190005 05003b19 4 34MB 21MB 1536MB LVDS1 DP3 Special Notes: For HD515, HD520, HD530 and HD540, you do not need to use device-id faking, they're natively recognised. I would recommend you keep the AAPL,ig-platform-id automatically recognised for each device-id by commenting/removing its entry in the config, otherwise it is recommended to choose 00001619. For HD510 you may need to use device-id=02190000 to fake its device-id. You would need also to use AAPL,ig-platform-id=00001B19 or 00001619 For HD550 and P530 (and potentially all HD P-series iGPUs), you may need to use device-id=16190000(recommended) or 12190000 or 26190000 or 1b190000 The choice of device-id may help with usable screen on boot up and on wake. For example Lenovo ThinkPad P50 with Xeon CPU will only properly work with 1619. For example Dell Precision 7710 with i7 CPU has issues when set to 1619, using 1b19 or something else may help. It is also recommended using 2619 with Xeon iGPUs. You may also pair it with a proper AAPL,ig-platform-id=00001619(recommended) or 00001219 or 00002619 or 00001b19 In some cases where you cannot set the DVMT-prealloc of these cards to 64MB higher in your UEFI Setup, you may get a kernel panic. Usually they're configured for 32MB of DVMT-prealloc, in that case these values are added to your iGPU Properties | Key | Type | Value | | :--- | :--- | :--- | | framebuffer-patch-enable | Number | 1 | | framebuffer-stolenmem | Data | 00003001 | | framebuffer-fbmem | Data | 00009000 | Intel Kaby Lake, KBL-R, & Amber Lake iGPU device-id AAPL,ig-platform-id Port Count Stolen Memory Framebuffer Memory Video RAM Connectors Intel HD Graphics 620 16590000 00001659 3 34MB 0MB 1536MB LVDS1 DP2 Intel HD Graphics 620 16590009 09001659 3 38MB 0MB 1536MB LVDS1 DP2 Unlisted iGPU 18590002 02001859 0 0MB 0MB 1536MB Connector: Intel HD Graphics 630 1b590000 00001b59 3 38MB 21MB 1536MB LVDS1 DP2 Intel HD Graphics 630 1b590006 06001b59 1 38MB 0MB 1536MB LVDS1 Unlisted iGPU 1c590005 05001c59 3 57MB 0MB 1536MB LVDS1 DP2 Intel HD Graphics 615 1e590000 00001e59 3 34MB 0MB 1536MB LVDS1 DP2 Intel HD Graphics 615 1e590001 01001e59 3 38MB 0MB 1536MB LVDS1 DP2 Intel Iris Plus Graphics 640 26590002 02002659 3 57MB 0MB 1536MB LVDS1 DP2 Intel Iris Plus Graphics 650 27590004 04002759 3 57MB 0MB 1536MB LVDS1 DP2 Intel Iris Plus Graphics 650 27590009 09002759 3 38MB 0MB 1536MB LVDS1 DP2 Intel UHD Graphics 617 C0870000 0000C087 3 34MB 0MB 1536MB LVDS1 DP2 Intel UHD Graphics 617 C0870005 0500C087 3 57MB 0MB 1536MB LVDS1 DP2 Special Notes: For HD615, HD620, HD630, HD640 and HD650 it is not needed to use a device-id, however due to many issues with different setups it is recommended to use: device-id=1b590000 or 16590000 AAPL,ig-platform-id=00001659 or 00001b59 (you can try whichever works the best, some even try to cross the device-id and the ig-platform-id) For HD620 users, they can skip the part above (unless you get issues) For UHD620 users, you must use: device-id=C0870000 AAPL,ig-platform-id=0000C087 Note: UHD630 IS NOT KabyLake, it's CoffeeLake (check next section). For all HD6** (UHD users are not concerned), there are some small issues with output where plugging anything would cause a lock up (kernel panic), here are some patches to mitigate that (credit Rehabman): 0306 to 0105 (will probably explain what it does one day) | Key | Type | Value | | :--- | :--- | :--- | | framebuffer-con1-enable | Number | 1 | | framebuffer-con1-alldata | Data | 01050A00 00080000 87010000 02040A00 00080000 87010000 FF000000 01000000 20000000 | 0204 to 0105 (will probably explain what it does one day) | Key | Type | Value | | :--- | :--- | :--- | | framebuffer-con1-enable | Number | 1 | | framebuffer-con1-alldata | Data | 01050A00 00080000 87010000 03060A00 00040000 87010000 FF000000 01000000 20000000 | In some cases where you cannot set the DVMT-prealloc of these cards to 64MB higher in your UEFI Setup, you may get a kernel panic. Usually they're configured for 32MB of DVMT-prealloc, in that case these values are added to your iGPU Properties | Key | Type | Value | | :--- | :--- | :--- | | framebuffer-patch-enable | Number | 1 | | framebuffer-stolenmem | Data | 00003001 | | framebuffer-fbmem | Data | 00009000 | Intel Coffee Lake, Comet Lake (14nm++++++) iGPU device-id AAPL,ig-platform-id Port Count Stolen Memory Framebuffer Memory Video RAM Connectors Intel UHD Graphics 630 003E0000 0000003E 3 57MB 0MB 1536MB LVDS1 DP2 Intel UHD Graphics 630 923E0000 0000923E 3 57MB 0MB 1536MB LVDS1 DP2 Intel UHD Graphics 630 923E0009 0900923E 3 57MB 0MB 1536MB LVDS1 DUMMY2 Intel UHD Graphics 630 9B3E0000 00009B3E 3 57MB 0MB 1536MB LVDS1 DP2 Intel UHD Graphics 630 9B3E0006 06009B3E 1 38MB 0MB 1536MB LVDS1 DUMMY2 Intel UHD Graphics 630 9B3E0009 09009B3E 3 57MB 0MB 1536MB LVDS1 DP2 Intel Iris Plus Graphics 655 A53E0000 0000A53E 3 57MB 0MB 1536MB LVDS1 DP2 Intel Iris Plus Graphics 655 A53E0004 0400A53E 3 57MB 0MB 1536MB LVDS1 DP2 Intel UHD Graphics 630 A53E0005 0500A53E 3 57MB 0MB 1536MB LVDS1 DP2 Intel Iris Plus Graphics 655 A53E0009 0900A53E 3 57MB 0MB 1536MB LVDS1 DP2 Unlisted iGPU A63E0005 0500A63E 3 57MB 0MB 1536MB LVDS1 DP2 Special Notes: For UHD630 you may not need to fake the device-id as long as it's 8086:9B3E, if it's anything else, you may use device-id=9B3E0000 For UHD620 in a Comet Lake CPU requires: device-id=9B3E0000 AAPL,ig-platform-id=00009B3E Intel IceLake (soon™) to be filled Panel Backlight Whatevergreen will enable your panel backlight, but to do so you usually have to provide configuration. Because this is OpenCore, the only method we can use is adding the SSDT-PNLF. We'll do that by compiling PNLF SSDT from the Whatevergreen source repository and placing it in OpenCore/ACPI/. First, save the dsl to your home directory. SSDT-PNLF.dsl @ Github SSDT-PNLFCFL.dsl @ AppleLife.ru Use the SSDT-PNLF.dsl with any iGPU Generation. Use SSDT-PNLFCFL.dsl with CoffeeLake (and potentially later releases). DO NOT USE BOTH AT THE SAME TIME. Now that you've saved the file, you'll need to compile it. For that, we need to download maciASL if you are on macOS, or iASL if you are on linux or windows. maciASL Project @ Github Run maciASL, and open the SSDT-PNLF.dsl that you created previously. Save the file to OpenCore/ACPI/SSDT-PNLF.aml. If you are using windows or linux, run path/to/iasl SSDT-PNLF.dsl. Special note for CoffeeLake and later: You might also want to try adding these boot arguments / device properties (recommended) to your configuration: igfxcflbklt=1 or enable-cfl-backlight-fix=1(Number) to enable CFL backlight patch -igfxmlr or enable-dpcd-max-link-rate-fix=1(Number) to apply the maximum link rate fix (for some high resolution laptop screens like on XPS15 and others) Verifying Metal Support This one's easy, just click Apple > About This Mac > System Report, and click Graphics/Displays. You should see a line that looks like this. Metal: Supported, feature set macOS GPUFamily2 v1 If you don't see it, you may have some additional work to do. Verifying HEVC Encoding If you're using a system configured to act like a 2015 or earlier Macbook/Macbook Pro, stop here because it's not supported. Otherwise you can verify that it's working after macOS is installed by installing VideoProc (Free version is fine). VideoProc can be used to test H264 encoding and decoding as it should be supported even if HEVC isn't. Download VideoProc Once you are in the application, click Settings (Bottom right) followed by the Options button next to Hardware Acceleration engine. If everything is working properly all of the boxes should be checked. All set? Great! "},"prepare-install-macos/usb-pre-setup.html":{"url":"prepare-install-macos/usb-pre-setup.html","title":"USB pre-setup","keywords":"","body":"USB pre-setup USB ports and controllers on macOS are one of the most tricky parts of a hackintosh. Ever since 10.11, Apple decided to change the way macOS handles the ports and controllers and how many can it handle, which would limit the number of ports. You can know more about that here: USB Map by CorpNewt @ Gitbook 10.11+ USB changes and solutions by Rehabman @ tonymacx86 forums In this part of the guide, we will see how to temporary fix your USB drives for the installer section. This is only a TEMPORARY fix, do NOT keep it as permanent solution. Getting USBInjectAll This driver would enumerate all the USB ports available in your system (following the ACPI tables) and inject all of them to macOS, this would let macOS see *most* of the ports. The reason why it wouldn't see all of them is because of the Port Limit. However we're going to use USBInjectAll to limit some ports when we need it. If you did not get it already when making the USB, add it now. Remember to add it to your config.plist as well. USBInjectAll Project - Rehabman @ BitBucket For USB2.0 flash drives You do not need anything more to do, you can just plug and use it for the installer, make sure you get USBInjectAll. In case you have an Ivy Bridge up to Broadwell laptop, make sure that change EHC1 to EH01 and change EHC2 to EH02 ACPI patches are disabled. If you have a USB3.0 port, plug the drive in it. For USB3.0 flash drives USBInjectAll would inject all the USB ports detected beginning with USB2.0 personalities. And since most controllers support at least 11 USB2.0 personalities, it would fill up the maximum allowed ports by macOS (check the CorpNewt guide above to understand more about that). To fix this, we can try and limit some ports from showing up to keep room for USB3.0 personalities to show up (since 1 USB3.0 personality = 2 ports count, and 1 USB2.0 personality = 1 port count). Solution #1 Use a USB2.0 drive and see the above section. Solution #2 Use a USB2.0 hub or extension cord to force the USB3.0 drive to run in USB2.0 mode. Solution #3 On Windows, plug your USB3.0 drive in a USB3.0 port. In case you have a Skylake (6th Gen intel) platform, you have only one controller (XHCI, for USB3.0), if you have Broadwell or earlier, you have two controllers (XHCI, USB3.0, and EHCI, USB2.0), either way use the USB3.0 port of your device. Right click on Start > Device Manager, highlight \"USB Root Hub (USB3.0)\" or \"Intel(R) USB 3.0 eXtensible Host Controller\" under \"Universal Serial Bus Controller\" section: Then select View > Devices by connection Your setup should look something similar to this, Under USB Root Hub you'll see your connected USB devices (USB3.0 ports, in this case even my internal USB devices since I only have an XHCI controller, for Broadwell and earlier you may find the internal USB devices under EHCI, we do not need to care about those). You should see your USB drive under this section, OR under a USB Hub, either way look for the root device under USB Root Hub that leads to your USB3.0 drive (it can also be the USB3.0 drive itself). Select your drive and double click on it, or right click > Properties, in this example, I'll select \"Generic USB Hub\": Go to Details > and choose under Property list: \"BIOS device name\" Here, we can see where the BIOS/UEFI's ACPI has defined the port location and Name. In this case it's named HS03, for USB3.0 devices it should be named SSxx (in some cases it's named SSPx, usually it's SSxx). In case it's named HSxx you can just go and start your macOS installer, if it's named SSxx make sure to check if you have a USB keyboard and do the same process as above and make sure you remember its name, usually it's connected to a USB2.0 personality in the XHCI controller, so it's going to be named as HSxx instead of SSxx. At this point, if you have a USB attached Mouse/Trackpad (some laptops have it connected through PS2 like seen in the section before), do the same process as above and make sure you remember its name, usually it's connected to a USB2.0 personality in the XHCI controller, so it's going to be named as HSxx instead of SSxx. If you happen to use a Bluetooth mouse, it's better if you change it for a USB one, Bluetooth on macOS is quite a hassle also it's not going to work properly in the installer environment. Now go back to your config.plist > NVRAM > Add > ... > boot-args. Here you're going to add these arguments: -uia_exclude_hs uia_include=HSxx,SSxx Explanations: -uia_exclude_hs is a boot argument read by USBInjectAll driver that would tell it to disable the enumeration and injection of all HS (USB2.0) personalities, leaving some sports for the SS (USB3.0) personalities to be injected (lifting the 15 ports limit by removing some ports). uia_include:HSxx,SSxx is a boot argument read by USBInjectAll driver that would include some excluded ports and with that we can include USB mice/keyboards that we got the IDs of before. There is no need to include any SS device, since they're all included anyways. So your argument will look something like this: uia_include=HS03,HS05 (if, for example, your USB devices that you want to keep and are USB2.0 devices named HS03 and HS05). Save your config.plist. With this you can continue the setup and review your Installation files. "},"prepare-install-macos/pre-installation-review.html":{"url":"prepare-install-macos/pre-installation-review.html","title":"Pre-Installation Review","keywords":"","body":"Pre-Installation Review Congratulations! If you've made it this far you should be ready to install macOS. Before we do, take one last look at your EFI configuration to make sure it matches the tree view below. EFI ├── BOOT │ └── BOOTX64.efi └── OC ├── ACPI │ ├── SSDT-GPI0.aml │ ├── SSDT-PNLF.aml │ └── SSDT-XOSI.aml ├── OpenCore.efi ├── config.plist ├── Drivers │ ├── ApfsDriverLoader.efi │ ├── FwRuntimeServices.efi │ └── HFSPlus.efi ├── Kexts │ ├── Lilu.kext │ ├── NoTouchID.kext │ ├── SMCBatteryManager.kext // if it spams the verbose log with Battery reading errors remove it for later. │ ├── SMCLightSensor.kext // Only use if you have a light sensor. │ ├── SMCProcessor.kext │ ├── SMCSuperIO.kext // IO status reporting, causes panics on some systems. Remove it. │ ├── USBInjectAll.kext │ ├── VirtualSMC.kext │ ├── VoodooI2C.kext // for I2C setups │ ├── VoodooI2CHID.kext // for I2C setups │ ├── VoodooInput.kext // if using VoodooPS2 from acidanthera │ └── VoodooPS2Controller.kext └── Tools // These aren't needed to boot but can be useful ├── VerifyMSR2.efi └── acpidump.efi Looks good? Great! Let's start the installation! "},"installing/installing-the-operating-system.html":{"url":"installing/installing-the-operating-system.html","title":"Installing the Operating System","keywords":"","body":"Installing the Operating System Now that you have your installation media created, boot your USB stick and select the macOS installer. Provided everything goes as planned, you should be presented with a tools window that looks similar to the image below. Prepare Your HDD/SDD for macOS Before installing macOS, you need to create an APFS volume on your destination disk. To do this, we'll use Disk Utility. Click it in the Utilities menu, and select Continue. Once Disk Utility opens, we'll need to show all devices like we did when preparing the USB media. Plug the USB stick into your computer, and open Disk Utility. In Disk Utility, select View and then Show All Devices. Select the media you will be installing macOS onto, and then Erase. Erase the drive using a GUID partition map, and the APFS filesystem. Once the drive is formatted, close Disk Utility which will return you to the macOS Utilities menu. Installing macOS Now that your media has been formatted, it's time to install macOS! Select Reinstall macOS from the menu and click Continue. Select your newly formatted APFS volume, and install macOS. There are multiple phases to macOS installation, don't be surprised if there is a reboot during the install process. If everything goes as planned, it should boot to each phase automatically. Once the installation is complete, you should be presented with a welcome screen. Congratulations, you've installed! The fun is only just begining however as we still need to configure macOS to work with all of your hardware. Prohibited Sign & Broken Text If while booting macOS you come across a boot failure with a prohibited symbol and broken text, that means macOS could not find the root device while booting. It may look similar to the image below. This is a very common problem, and it's usually related to the USB device or the USB port that the device is plugged into. The first thing to try is moving the USB from one port to another, repeating until you're back where you started. You don't need to reboot, just move the stick and wait a few seconds to see if macOS finds it and progresses. If not, there are a few things you can do to try and fix it. You can check again USB pre-setup to see if you properly made your USBInjectAll setup. "},"installing/troubleshooting.html":{"url":"installing/troubleshooting.html","title":"Troubleshooting","keywords":"","body":"Troubleshooting Hackintosh Slav has a large page of errors and troubleshooting steps for Hackintoshes in general: Scrambled Login Screen Enable CSM in your UEFI settings. This may appear as \"Boot Legacy Roms\" or some other legacy setting. Trackpad does not work but keyboard, buttons, and trackstick do! Make sure that within your Config.plist under Kernal/Add, that VoodooInput is above/before any of the VoodooPS2 and VoodooI2C kexts. Voodooinput needs to be loaded before the VoodooPS2Trackpad kext specifically for it to attach and function. "},"post-installation/adding-clover-to-the-bios.html":{"url":"post-installation/adding-clover-to-the-bios.html","title":"Adding OpenCore to Your Boot Drive","keywords":"","body":"Adding OpenCore to Your Boot Drive Add OpenCore to Your Boot Drive At this point, you should be booting into macOS using your USB stick. So, how do we put OpenCore on your hard drive/ssd? Simple, we just need to copy it. This process is relatively painless, but we're going to need to use the terminal so open that now. First, we need to mount your USB EFI partition, and the EFI partition on your hard drive or SSD. Remember how we learned about using Disk Utility from the command line in the \"What's an EFI?\" section? Good, because we're doing it twice. Mount the USB EFI Let's find out which device is our USB stick. We'll use the following command for this: diskutil list Thumb drives are classified as \"external\" devices, so they're easy to locate. Find the device that matches your USB stick. Our example device is /dev/disk4 and our EFI is the second partition. /dev/disk4 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *16.0 GB disk4 1: EFI EFI 209.7 MB disk4s1 2: Apple_HFS macOS Install 15.7 GB disk4s2 Now that we know where our USB's EFI is, let's mount it. First we'll create a folder, and then we'll mount it. We'll call the folder 'USBEFI'. sudo mkdir /Volumes/USBEFI sudo diskutil mount -mountPoint /Volumes/USBEFI /dev/disk4s1 Alright, now we'll repeat the process for the internal EFI. This time we'll look for an internal physical disk that contains the internal drive's EFI. diskutil list /dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *500.1 GB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_APFS Container disk1 499.9 GB disk0s2 Our example is disk0 partition 1, so let's mount it on 'SYSEFI'. sudo mkdir /Volumes/SYSEFI sudo diskutil mount -mountPoint /Volumes/SYSEFI /dev/disk0s1 Now that we have both EFIs mounted we just need to copy the files. cd /Volumes/USBEFI cp -rf * ../SYSEFI Lastly, let's unmount those devices so we can reboot. diskutil unmount /Volumes/USBEFI Volume USBEFI on disk4s1 unmounted diskutil unmount /Volumes/SYSEFI Volume SYSEFI on disk0s1 unmounted That's it! Unmount your USB stick in Finder, and reboot without it. You may need to go into your BIOS and set Clover first in your boot order. If you're able to boot into OpenCore, you can skip the next section and move onto Display Configuration. Adding OpenCore to your BIOS Most newer computers will pick up Clover automatically, but if it doesn't appear as a bootable selection in your BIOS here's how to correct it. Quick Reference Guide map - Lists devices that you can boot from. drive: - Change to the drive you select. Ex. FS0: ls or dir - List the content of the selected drive. cd - Change directories. bcfg - Boot configuration, used to read and write BIOS boot data. Add OpenCore to your BIOS First, use map to find your devices. Once you have an idea of your device, select it by typing DEVICE: replacing device with the actual device. Ex. FS0: Use ls to determine the content of the device. It should contain an EFI folder. Use caution to make sure this device is not your USB stick. Use bcfg boot dump to view your currently configured boot devices (you may see your USB in this list for validation). Use bcfg boot add 00 FS0:\\EFI\\BOOT\\BOOTX64.EFI OpenCoreto add an entry to your boot map. 00 is the boot order ranking, 00 being the very first one, and it increments by one, 01 being the second, 02 being the third and so on. Rerun the boot dump command to verify. Reboot. Note that on some laptops with weird BIOS configurations (like InysideH2O on ACER or HP, and especially VAIO laptops), this may have no effect on boot priority and would still boot windows if it's still installed. You can check Fix Clovy Clovy in r/Hackintosh Multiboot guide. "},"post-installation/configuring-usb-ports.html":{"url":"post-installation/configuring-usb-ports.html","title":"Configuring USB Ports","keywords":"","body":"Configuring USB Ports I agree..the need to configure USB ports does sound a little weird, but it is a necessity on a Hackintosh as Apple uses a very strict configuration for USB and the macOS kernel does not autodetect and configure ports for you. You may be thinking that you don't need it because your USB ports seem to work fine, but mapping ports can help resolve instant wake problems, and things like bluetooth and touch screens not working properly. One item of note, if you ever have to change your SMBIOS it will invalidate your USB map and you'll have to map your ports again. Understanding Port Limits As mentioned previously, macOS has a very strict USB configuration by default, and that includes a hard limit of 15 USB ports. That doesn't sound like it's a big deal, but if your computer has USB 3.0 every 3.0 port uses 2 ports on the bus; a low speed port (HS) and a super speed port (SS). Your computer has both internal and external USB ports as well, so it's not as simple as just counting the ports you can see and doubling them. To correct this problem long enough to map the ports that you need, we need to add a few patches to the config.plist if they aren't already there. Once the port limit has been lifted and your ports have been mapped, disable the patches to prevent instability in macOS. Applying the Port Limit Patches DO NOT use these as a permanent solution, they're only temporary fixes until you map all your USB ports. Mount up your EFI partition if it isn't already and open your config.plist. Enable XhciPortLimit under Kernel -> Quirks Information About Port Types There are only three port types that you should be concerned with. These types and their descriptions can be found in the table below. Port Port description Type 0 This is a standard external USB 2.0 port. Type 3 This port is an external USB-A or USB-C 3.0 port. Type 255 This is a port on the motherboard for internal devices. Are My Devices Internal or External? Well, they're probably both actually. You would determine if it's an internal or external port by whether it is inside the computer, or outside as a port that you plug devices into. Some common examples can be found in the table below. Device Location Thumb Drives External Bluetooth inside my computer (m.2 or Mini PCIe) Internal Bluetooth that I plug in External Touch Screen Internal Webcam Internal WIFI Dongle External SDCard Reader that I plug in External Remember, internal devices are of type 255 and external devices depend on the type of port. If you don't know what kind of external ports you have, consult your laptop service manual or user guide. Inject All The Ports! A prerequisite to mapping your ports is injecting every port imagineable into your installation temporarily. That allows the mapping utility to see all of the ports available to your system. The kernel extension needed for this to work is called USBInjectAll, and it can be found in Rehabman's Bitbucket repository. Download the kext, and add it to C/k/O. You'll need to reboot before continuing. Download USBInjectAll @ Bitbucket Mapping USB Ports Now that you're armed with knowledge about your USB devices and you've fixed that pesky port limit, it's time to map your ports. So, what do we need to do to map the ports? Good question! For this, we need to use corpnewt's wonderful USBMap utility. Go ahead and download that now. It's important to read the utility's README for information on how to use the tool, and how to adjust your ports as described above. Visit USBMap @ Github After saving your changes, the USBMap tool will create several files and open a finder window. Take the USBMap.kext that you've just created and copy it to C/k/O. Delete USBInjectAll, you won't need it any longer. After verifying the ports you need are mapped and working properly, disable the port limit patches. "},"post-installation/enabling-wifi-and-bluetooth.html":{"url":"post-installation/enabling-wifi-and-bluetooth.html","title":"Enabling WIFI & Bluetooth","keywords":"","body":"Enabling WIFI & Bluetooth I get it, you want your Hackintosh to be able to access the internet and connect to your Bluetooth headphones. That's a noble goal, so let's get to work! Enabling WIFI & Bluetooth is pretty straight forward, but if you haven't swapped the card out for one of the supported devices that we talked about in the Know Your Hardware section, you're in for a bad time. Stop now and do that first. Remember, there are only a few compatible devices, and you really don't want to try to force the use of an unsupported device because it's cheaper, you'll just be throwing your money away. Before purchasing make sure the adapter matches the socket you'll be installing it into. Supported WIFI/Bluetooth Combo Cards Mini PCIe Adapters Chipset Antenna Models BCM94352HMB U.FL AzureWave AW-CE123H Dell DW1550 HP TPC-Q013 Lenovo WCBN606BH ### PCIe m.2 Adapters Chipset Antenna Models BCM94352Z MHF4 Dell DW1560 (A/E key) Lenovo 04X6020 (E key) ### Apple Native WIFI Cards Wireless cards manufactured by Apple are natively supported, however they use a proprietary 12+6 connector which requires an adapter to function in an mPCIe or m.2 socket. Before purchasing ensure your laptop has sufficient space for the card + adapter, and make sure to purchase the appropriate 12+6 to mPCIE or m.2 adapter. Chipset Antenna BCM94360CS2 MHF4 BCM943224PCIEBT2 MHF4 BCM94360CD M.FL Note: Be sure to use an adapter that is suited for your WLAN socket and only install to the WLAN socket. Other m.2 sockets may not have all of the paths needed for WIFI and Bluetooth to function. WWAN sockets may be USB or not available without modded BIOS. Configuring WIFI WIFI configuration is pretty straightforward, you only need an injector kext to help macOS see and configure the card. For that we'll need to download the AirportBrcmFixup kext from its project page at Github. Add the kext to OC/K and reboot when convenient. Don't forget to add the kext to your Config.plist as well. Download AirportBrcmFixup @ Github The location of the kext should match the tree below. EFI └── OpenCore └── Kexts └── AirportBrcmFixup.kext Setting up Bluetooth Internal Bluetooth devices are almost as easy, but they do require being configured as internal USB devices. If you haven't mapped your USB ports yet, do that first. Unless you're using a native Apple card you will need to download BrcmPatchRam from the Acidanthera repo. Within this package you will find several kexts. These kexts are detailed in the table below. Kext Use BrcmBluetoothInjector.kext Use when firmware loading is not required. BrcmPatchRAM.kext Loads firmware into the bluetooth device and activates it. For macOS 10.10 or earlier. BrcmPatchRAM2.kext Loads firmware into the bluetooth device and activates it. For macOS 10.10-10.14. BrcmPatchRAM3.kext Loads firmware into the bluetooth device and activates it. For macOS 10.15. BrcmFirmwareData.kext Provides firmware to BrcmPatchRAM2. Once you've determined the kexts that you'll need, add them to C/k/O and reboot. If you're unsure, start with BrcmBluetoothInjector.kext. If your Bluetooth device isn't working after a reboot, you need a firmwareloader. Add the appropriate BrcmPatchRAM?.kext along with BrcmFirmwareData.kext. Leave BrcmBluetoothInjector.kext as well as it is also required. Download BrcmPatchRam @ Github When finished, the kexts should be located in your EFI as indicated in the tree below. Don't forget to add the kexts to your Config.plist. EFI └── OC └── Kexts ├── BrcmBluetoothInjector.kext ├── BrcmPatchRAM{2,3}.kext └── BrcmFirmwareData.kext If you need additional help with installing and configuring WIFI and Bluetooth, you should read Toleda's Broadcom WiFi/Bluetooth guide which is linked below. Broadcom WiFi/Bluetooth [Guide] That wasn't so bad, right? "},"post-installation/setting-up-ethernet-adapters.html":{"url":"post-installation/setting-up-ethernet-adapters.html","title":"Setting up Ethernet Adapters","keywords":"","body":"Setting up Ethernet Adapters If your laptop has an Ethernet adapter, or you have a USB dongle that you'd like to use it's possible that it is compatible with macOS, but probably not by default. If it's a supportable device, it should be as simple as adding the kext to OC/K and your config.plist for macOS to see it. Internal Ethernet The table below contains a list of kexts that may support your ethernet adapter. Before adding them, research to make sure your device is supported! If it is, add the kext to C/k/O and reboot. Vendor Kext Atheros AtherosE2200Ethernet Broadcom BCM5722D Intel IntelMausiEthernet Realtek RealtekRTL8100 (10/100 Cards) RealtekRTL8111 (GbE Cards) Asix AX88179 ### External (USB) Ethernet for Installation If you need to add the driver to OpenCore to boot, you will need to extract the kext from the installation package after downloading. Here's how you can do that. Install The Unarchiver (App Store) Open the package's DMG to mount it. Copy the installation package from the DMG to a temporary directory. Right click (Control-Click) the package and open it with The Unarchiver. Open a terminal and change to the package directory that has been created. Follow the steps below. cd {package}.pkg tar -xvf Payload Copy the extracted kext to OC/K Add the kext to your Config.plist The USB adapter should be detected by macOS upon reboot into the installer. "},"post-installation/configuring-your-audio-device.html":{"url":"post-installation/configuring-your-audio-device.html","title":"Configuring your Audio Device","keywords":"","body":"Configuring your Audio Device Audio devices are much simpler to configure than they used to be thanks to the development of AppleALC. AppleALC is a kernel extension that provides native Apple audio capabilites. To use it, the first thing you will need to know is what audio codec your laptop uses. If you don't already know, or if you're unsure, you can use a Linux live USB to do a codec dump. A codec dump provides a treasure trove of information about your device and the paths it uses to connect things like internal amplifiers to speakers or headphones. Creating a Codec Dump If you do need a codec dump for whatever reason, boot from your Linux live USB and find the nearest terminal or command line. The following command will display the details of your codec on screen with a pause so you can read it. cat /proc/asound/card0/codec#0 | less The first line should provide your codec. It will look something like this: Codec: Realtek ALC294 If you would like to save the codec to a file so you can reference it again when you're back in macOS, cat it to a file instead and save the file to the boot partition of the USB drive, on another USB drive, or somewhere on your network. cat /proc/asound/card0/codec#0 > /mnt/MyOtherUSBDrive/codec.txt Now that you're familiar with your codec, let's install AppleALC. AppleALC Prerequisites If you're dual booting with Windows or Linux, you should enable the Devices/Audio/ResetHDA property which will reset the audio device on startup to flush any configuration . Installing AppleALC Installing AppleALC is simple. You just need to download the AppleALC kext from the project's release page and add the kext to OC/K. You can find it here. You may have it already if you installed it when making the USB. If you do add it, make sure to edit your config.plist Download AppleALC @ Github Your new AppleALC kext path should look like it does in the tree below. EFI └── OC └── Kexts └── AppleALC.kext Before rebooting, let's configure it! Configuring AppleALC This is where things can get a little tricky, as just about every implementation of the same codec is different. Knowing your codec makes things somewhat easier as you can look it up in the AppleALC WIKI and find all of the layouts that could work with it. AppleALC Supported Codecs If you don't find your codec listed, you might find that it's just a rebranded version of another so it wouldn't hurt to search for \"AppleALC {your codec}\". Once you have a list of layouts, but you don't know which is the right one you can test them one by one. Just configure the layout id in config.plist with your favorite plist editor and reboot. If audio works, congratulations! Otherwise, repeat until you've found it. Open up your plist editor and the config.plist, then browse to DeviceProperties/Add and set the alc-layout-id parameter to your layout id. It should look something like this. None of the Layout IDs Worked! Well, you still have some options although none of them will be fun. The first option would be to take that codec dump that we made earlier and build a new layout for your device, or you could try using VoodooHDA instead. Let's talk about both options. Creating a New Layout for AppleALC This nets the best benefit for you and for everyone else because you'll end up with native support and others with the same device can use it too. It's the most difficult option though. Here's some documentation to help get you started. HDA Fix - HaC Mini Hackintosh - by osy (Great guide on how to make your own HDA patches) AppleALC: Adding Codec Support Using VoodooHDA VoodooHDA is an alternative to AppleALC, and it works pretty well but rather than adding native support, VoodooHDA provides its own audio solution. Installing it is pretty straightforward. Simply download the kext, preference pane, and settings loader and add them to your system. The kext goes in C/k/O, if you have AppleALC installed you'll want to remove it. Open (execute) the preferences pane and it should prompt you to install, if it doesn't drag it onto System Preferences and it'll install that way. The settings loader should be installed to Applications, and you should run it once to enable it. They can be downloaded here. Download VoodooHDA @ SourceForge As with AppleALC, it should follow the same pattern in the tree. EFI └── OC └── Kexts └── VoodooHDA.kext "},"battery-power-management/locate-that-missing-battery.html":{"url":"battery-power-management/locate-that-missing-battery.html","title":"Locate that Missing Battery","keywords":"","body":"Locate that Missing Battery First thing I have to ask is this. Is it actually missing? Often just installing VirtualSMC is all that it takes for your battery status to appear. If it's there, there's nothing to see here, and it's safe to move onto the next section! Oh, you're still here? Well...unfortunately that means this is going to be one of our more painful endeavors as it requires DSDT patches. Fortunately, you've already studied applying hotpatches, so there's no need to cover it again. Let's jump right into the basics to get you started. DSDT Battery Status Patching First of all, you're going to need to dust off maciASL. Remember that? You used it to compile the SSDT patches for your touchpad. This is going to be a little different. Here's the 101. Dumping your DSDT The first step in getting ready to patch your DSDT is to get a copy of it from your firmware. You can do this by rebooting your computer and pressing F4 at the OpenCore menu, before launching macOS. That instructs OpenCore to drop a copy of it in your EFI partition under OpenCore/ACPI/origin. You should also still have the DSDT from when you configured your EC. Patching the DSDT This is a little more advanced, so after getting you started you're going to have to study some documentation and really understand what it is that you're doing as the DSDT is quite fragile. Open maciASL, then open your DSDT file. You should be presented with quite an array of data about your system. If you get an error right away, that means you'll want to go into preferences and change your iASL and then close and re-open the DSDT. To do that, open Preferences of maciASL, click iASL and select Legacy. If Legacy is already selected change it to Stable. You'll also want to click the Update iASL button before closing. Alright, now that you're in maciASL and you have your DSDT open comes the hard part. Finding patches that work for your system. In maciASL you'll notice that at the top center of the main window are two options; Compile, and Patch. Click Patch and in the left pane of the window that opens you should find a whole bunch of patch repositories already configured for you. Find Rehabman in the tree. Under this section you will find a large selection of patches for various laptops. After making a backup of your DSDT, try applying the patches for systems that are most similar to yours. You might get lucky and have no more work to do. If those don't work, you're going to have to get personal with Rehabman's battery patching guide and your DSDT. When adding your DSDT to the ACPI folder and your config.plist, make sure that it is the first thing injected. The order should be DSDT then all of your others SSDT in your config.plist. [Guide] How to patch DSDT for working battery status This one could take a while, but don't worry..the next section will be here waiting for your click! "},"battery-power-management/correcting-sleep-problems.html":{"url":"battery-power-management/correcting-sleep-problems.html","title":"Correcting Sleep Problems","keywords":"","body":"Correcting Sleep Problems Are you experiencing a condition where you tell your computer to sleep, and it starts to do as instructed but then laughs in your face? Well, you are not alone! That's a condition that most of us face, but we can fix it! There are a few things that can cause this problem, some of which we've corrected before ever reaching this section (How about that!). Let's talk about each one. USB Port Mapping That's right..if you're using USBInjectAll in its default configuration, or you have no USB port injection at all, it could cause this condition. That isn't a problem for you though because we've already fixed it. Disabling Hibernation Hibernation isn't well supported on hackintoshes, and in some cases it doesn't work at all. We can mitigate this problem by configuring macOS to use standby mode which will preserve what's in memory on sleep but will not write it out to disk and power off the machine. This may help to lenghten your SSD's lifespan but at the cost of losing all your work if the laptop was in sleep mode and power ran out or when the power is so low macOS will just shutdown and not enter hibernation mode. sudo pmset hibernatemode 0 sudo pmset standby 0 sudo pmset autopoweroff 0 Finding Wake Reasons for Correction Before talking about the remaining items that cause wakeups, we need to talk about how to tell what's waking your system up. There are a couple of very common reasons and the correction is similar for all of them. To find out what's waking your system, put it to sleep. Do it right now. Alright, it's probably already woken up so let's take a look at the log. pmset -g log | grep -e \"Wake.*due to \" Yep, that's a ton of data. You're looking for a couple of specific things though and they should be pretty close to the bottom of the log. Wake on GLAN/LANC If you see an entry in the log that looks similar to this one, you'll need to disable Wake on Lan in your BIOS. If that doesn't work, a patch is necessary. Wake [CDNVA] due to GLAN: Using AC Wake on HDEF This message looks similar to the GLAN log entry. If you see it, you definitely need a patch. Wake [CDNVA] due to HDEF﻿: Using AC Wake on XHCI This message is one of the most common that you may come across. It also looks similar to the other messages in the log. If you see it, you need a patch. Wake [CDNVA] due to XHC﻿: Using AC RTC/Maintenance Wakes Maintenance wakes are normal behavior, and are related to PowerNap. When PowerNap is enabled your computer will wake up to check email, initiate Time Machine backups, and sync with iCloud. Those wakes look similar to the following. DarkWake from Normal Sleep [CDNPB] : due to RTC/Maintenance Using AC If these wakes are not desired, disable PowerNap. Wake on RTC Alarm RTC Alarm wakes are generated by applications that use enhanced notifications that are left running while the system is asleep. Examples of applications that cause this wake type would be Messages, or Facebook. Those wakes may look like this. Wake reason: RTC (Alarm) If these wakes are undesirable, close any applications that may create them before allowing the device to sleep. Patching To Correct Sleep Issues The good news is that you can probably correct all of these issues with a single OpenCore configuration change and SSDT hotpatch from Rehabman! Determine which patch you need by inspecting your DSDT and matching the methods to the patches below. Patch Method #1 (GPRW,2,N) Search your DSDT for PRW. If you find method GPRW, use these patches. Use your favorite plist editor to add this patch to the ACPI/Patch array in config.plist. Key Type Value Comment String change Method(GPRW,2,N) to XPRW, pair with SSDT-GPRW.aml Enabled Bool True Find Data 4750525702 Replace Data 5850525702 Compile this patch with maciASL and save as OC/ACPI/SSDT-GPRW.aml. Don't forget to add it to your Config.plist as well. // For solving instant wake by hooking GPRW or UPRW // Credit: Rehabman // Modified to work without some extra setup DefinitionBlock(\"\", \"SSDT\", 2, \"hack\", \"_GPRW\", 0) { External(XPRW, MethodObj) // In DSDT, native GPRW is renamed to XPRW with OpenCore binpatch. // As a result, calls to GPRW land here. // The purpose of this implementation is to avoid \"instant wake\" // by returning 0 in the second position (sleep state supported) // of the return package. Method(GPRW, 2) { For (,,) { If (0x6d == Arg0) { Return (Package() { 0x6d, 0, }) } If (0x0d == Arg0) { Return (Package() { 0x0d, 0, }) } Break } Return (XPRW(Arg0, Arg1)) } } Patch Method #2 (UPRW,2,N) Search your DSDT for PRW. If you find method UPRW, use these patches. Use your favorite plist editor to add this patch to the ACPI/Patch array in config.plist. Key Type Value Comment String change Method(UPRW,2,N) to XPRW, pair with SSDT-UPRW.aml Enabled Bool True Find Data 555052570a7012 Replace Data 585052570a7012 Compile this patch with maciASL and save as OC/ACPI/SSDT-UPRW.aml. Don't forget to add it to your config.plist as well. // For solving instant wake by hooking GPRW or UPRW // Credit: Rehabman // Modified to work without some extra setup DefinitionBlock(\"\", \"SSDT\", 2, \"hack\", \"_UPRW\", 0) { External(XPRW, MethodObj) // In DSDT, native UPRW is renamed to XPRW with OpenCore binpatch. // As a result, calls to UPRW land here. // The purpose of this implementation is to avoid \"instant wake\" // by returning 0 in the second position (sleep state supported) // of the return package. Method(UPRW, 2) { For (,,) { If (0x6d == Arg0) { Return (Package() { 0x6d, 0, }) } If (0x0d == Arg0) { Return (Package() { 0x0d, 0, }) } } Return (XPRW(Arg0, Arg1)) } } Patch Method #3 LANC (_PRW,2,N) Search your DSDT for PRW. If you find method LANC _PRW, use these patches. Use your favorite plist editor to add this patch to the ACPI/Patch array in config.plist. Key Type Value Comment String change LANC (_PRW,0,S) to (XPRW,0,..), pair with SSDT-LANCPRW.aml Disabled Bool False Find Data 00001900141f5f50525708 Replace Data 00001900141f5850525708 Compile this patch with maciASL and save as OC/ACPI/SSDT-LANCPRW.aml. Don't forget to add it to your config.plist as well. // For solving instant wake by hooking GPRW // Credit: Rehabman // Modified to work without some extra setup DefinitionBlock(\"\", \"SSDT\", 2, \"hack\", \"_LANCPRW\", 0) { External(XPRW, MethodObj) // In DSDT, native LANC._PRW is renamed XPRW with OpenCore binpatch. // As a result, calls to LANC._PRW land here. // The purpose of this implementation is to avoid \"instant wake\" // by returning 0 in the second position (sleep state supported) // of the return package. // LANC._PRW is renamed to XPRW so we can replace it here // LANC can be named as GLAN or other names, make sure you match it // with the one in your ACPI. External(_SB.PCI0.LANC.XPRW, MethodObj) Method(_SB.PCI0.LANC._PRW) { Local0 = \\_SB.PCI0.LANC.XPRW() For (,,) { Local0[1] = 0 } Return(Local0) } } Laptop Still Have Insomnia? In that case, you're going to have to create a custom patch for your system, here's a guide that should help you out. [Guide] Using Clover to \"hotpatch\" ACPI "},"battery-power-management/optimizing-battery-life.html":{"url":"battery-power-management/optimizing-battery-life.html","title":"Optimizing Battery Life","keywords":"","body":"Optimizing Battery Life You may notice that your laptop uses a lot of power, possibly more than it did when you were using Windows. That's because Apple is configuring your device to operate like an Apple device. Since you have different hardware, you have a few extra steps to take to optimize battery life. Below you will find a few methods to test power usage, and to adjust your system parameters to improve battery life. Measuring Power in macOS macOS exposes overall power usage under the SPPowerDataType data type. You can find the data either using terminal, or using coconut battery. Here's a simple function that calculates watts on demand. watts() { FORMULA=$(system_profiler SPPowerDataType | awk '/Amperage\\ \\(mA\\):/ {printf $3\" * \"}; /Voltage\\ \\(mV\\):/ {print $3}') WATTS=$(echo \"scale=3; ${FORMULA} / 1000000\" | bc 2>/dev/null) if ! [[ ${WATTS} =~ [0-9] ]]; then WATTS=0 fi echo \"${WATTS} mW\" } Run it in a terminal to create a function called 'watts'. If you would like the command to be persistent, you should add it to your user profile (~/.profile). You'll see a negative number when you're discharging which is your discharge watts. When you're charging that number will be positive, that's the power draw of charging. If you see a negative number while charging, you're probably in the 97-100% range and overcharging protection is preventing the computer from charging. Below is another function that is similar to Activity Monitor's Energy tab, but run from a terminal. powertop() { top -stats pid,command,power -o power } As before it isn't persistent, so you'll want to add it to your profile if you want to use it after a reboot or after you close the terminal. To use it, just run 'powertop'. Another command that you can use to track energy usage is called powermetrics. It is a macOS built-in command that will provide more in-depth stats on what your CPU is actually doing. sudo powermetrics --show-process-energy Coconut Battery If you prefer GUI tools, or would like power usage in your menu bar, CoconutBattery is a great resource. You may notice that you aren't getting any cycle count statistics and your battery temperature is reporting -273C. Don't worry about that, your battery probably doesn't have those features. Visit the Coconut Battery website Optimizing Your Battery Life CPUFriend If you are using the SMBIOS of a 2015+ Macbook or 2016+ Macbook Pro, the tool for this job is called CPUFriend and you can download it from Github. If you are using the SMBIOS of an earlier Macbook or Macbook Pro, skip to the ssdtPRGen section instead. Download CPUFriend @ Github CPUFriend needs a helper to operate properly on your system, and corpnewt has written a tool that will help you do exactly that called CPUFriendFriend. Visit the project page for instructions on how to download and use it. CPUFriendFriend @ Github When you run CPUFriendFriend you will be prompted to enter your base clock speed. This is the TDP-down clock rate if supported. If you don't know, or if it isn't disclosed, try 800MHz. Look your CPU up on Intel's Ark website to find the data that you need. Visit Intel's Ark Website Next you will be asked to enter an EPP value. This is explained in the instructions, but below is a table that may help you make your decision. Value Description 0x00 Performance - Instructs the processor to scale as fast as possible. 0x40 Balance performance - Scale at a rate that offers better performance while considering battery life. 0x80 Balance power - Scale at a rate that prefers battery life while slightly sacrificing performance. 0xC0 Max Power saving - Sacrifice performance for battery life while still performing well enough for normal tasks. Once CPUFriendFriend has been run, copy the CPUFriend and CPUFriendDataProvider kexts to OC/K. Don't forget to add the kexts to your config.plist Once that's finished, open your config.plist and make sure that you have SSDT-PLUG. Finally, reboot. You should immediately notice a difference in battery life. ssdtPRGen Users of SMBIOS of Macbook Pros earlier than 2016 should use tool called ssdtPRGen written by Piker Alpha to configure scaling. Visit the project page and use the tool to create an SSDT for your CPU. Visit ssdtPRGen @ Github Using ssdtPRGen is relatively simple, run the utility and follow the prompts. This will create a frequency configuration for your system and place the files in ~/Library/ssdtPRGen. Copy ~/Library/ssdtPRGen/ssdt.aml to OpenCore/ACPI/, and update your config.plist. "},"extras/enabling-filevault.html":{"url":"extras/enabling-filevault.html","title":"Enabling FileVault","keywords":"","body":"Enabling FileVault What the heck is FileVault? FileVault is Apple's solution to whole disk encryption. Once enabled, it will use your CPUs encryption extensions to encrypt and decrypt data as you're using it. The credentials to unlock the disk are tied to your user and iCloud accounts, and integrated into the system for a relatively seemless experience. Setting up FileVault You should never just enable FileVault on a Hackintosh without first installing the prerequisites. Doing so will encrypt your disk, leaving you stuck. OpenCore was made with security/filevault in mind so it has good support assuming it is set up correctly. If you want to set it up, take a look at the page linked above. "},"extras/display-rotation.html":{"url":"extras/display-rotation.html","title":"Display Rotation","keywords":"","body":"Display Rotation MacOS does not provide a facility to rotate your display outside of System Preferences. To work around this, we'll use a display rotation helper. Install the Display Rotation Helper First download the latest version of DisplayRotation. Download DisplayRotation @ Github Copy the Rotation folder to /Applications. Double click each of the services and import them into Automator. Open System Preferences/Keyboard/Shortcuts/Services Configure the following service shortcuts: Standard Rotation: Command+Option+Control+Up Arrow Rotate 90 Degrees: Command+Option+Control+Left Arrow Rotate 180 Degrees: Command+Option+Control+Down Arrow Rotate 270 Degrees: Command+Option+Control+Right Arrow Open each application with right-click + Open beginning with Standard Rotation. If you get stuck, use the standard rotation shortcut to reset the display orientation. Changing Display Orientation Use the keyboard shortcuts or application wrappers to change orientation of your display. "},"extras/dual-booting-with-bluetooth-devices.html":{"url":"extras/dual-booting-with-bluetooth-devices.html","title":"Dual booting​ with Bluetooth Devices","keywords":"","body":"Dual booting​ with Bluetooth Devices Pairing with Windows and macOS Hackintosh users often dual boot with Windows and want to use their keyboards, mice, and other Bluetooth devices regardless of the OS they've booted. While it seems like an impossible task, it's actually relatively simple by sharing the macOS paring keys with Windows the same way Bootcamp does on a real Mac. First things first, you have to pair the device in Windows. I know that seems a little weird, but this is required so Windows has the registry keys that we need to update later. After that, boot into macOS and pair it there. Once it's paired, you will need to get the link keys from the bluetooth plist in macOS. If you're unsure which link key is which, you can find the MAC address of your device by option-clicking the Bluetooth applet in your menu bar and expanding the connected device you want to share. To get the keys, run the following command in terminal: sudo defaults read /private/var/root/Library/Preferences/com.apple.Bluetoothd.plist LinkKeys To find the link key for the device, match the devices MAC address in the output. The value assigned to the MAC address is the link key. It may look something like this: { “00-11-22-33-44-55” = { “aa-bb-cc-dd-ee-ff“ = ; }; } Once you have the link key, convert the endianness (big endian to little endian) so you can use it in Windows. Using the link key in the block above, the conversion would look like this: 01122334 45566778 89900112 23344556 56453423 12019089 78675645 34231201 Save the MAC address and the converted key in a location where you can retrieve it in Windows, and reboot into Windows with the device turned off. Open regedit and browse to the Bluetooth keys. HKLM\\SYSTEM\\CurrentControlSet\\Services\\BTHPORT\\Parameters\\Keys Replace the existing key matching the device's MAC address with the key that you converted in the earlier step. Restart the machine with the device turned on. Note: If you're using an Apple device such as a Keyboard or Trackpad, do not plug the device into your computer for charging. Doing so will cause the link keys to change requiring you to repeat this process again. "},"extras/asussmc.html":{"url":"extras/asussmc.html","title":"ASUS Function Keys","keywords":"","body":"ASUS Function Keys If you're here, you probably have an ASUS laptop that has special function keys, and/or a backlit keyboard that you might want to enable in macOS. This functionality can be enabled, but it requires a VirtualSMC Plugin called AsusSMC. This plugin and associated daemon can manage your keyboard backlight and all of the special keys on your keyboard. Setting it up can be complex, and may be different across different models. Rather than try and explain it all, here's a link to the project which provides all of the documentation that you should need. The AsusSMC Project @ Github "}}